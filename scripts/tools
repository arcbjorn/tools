#!/bin/bash

# Tools launcher - Interactive tool selector using gum
set -e

# Directories
TOOLS_DIR="/home/arc/tools"
BIN_DIR="$TOOLS_DIR/bin"
SCRIPTS_DIR="$TOOLS_DIR/scripts"

# Check if gum is available
if ! command -v gum >/dev/null 2>&1; then
    echo "Error: gum is required but not installed"
    echo "Install with: pacman -S gum"
    exit 1
fi

# Theme-aware colors using terminal palette slots (matching manage.sh)
readonly RED='\033[38;5;1m'
readonly GREEN='\033[38;5;2m'
readonly YELLOW='\033[38;5;3m'
readonly BLUE='\033[38;5;4m'
readonly MAGENTA='\033[38;5;5m'
readonly CYAN='\033[38;5;6m'
readonly WHITE='\033[38;5;7m'
readonly NC='\033[0m'

# Get concise, informative descriptions
get_description() {
    local file="$1"
    local basename=$(basename "$file")
    
    case "$basename" in
        # Assistant configuration
        configure-assistants-global) echo "Configure global assistant settings (Claude, Codex, Gemini)" ;;
        clean-global-assistants-configs) echo "Remove global assistant configuration files" ;;
        configure-cc-glm) echo "Configure Claude GLM integration" ;;
        create-assistant-command) echo "Create new assistant command/prompt templates" ;;
        sync-assistant-commands) echo "Sync assistant commands to global directories" ;;
        
        # Repository management
        attach-existing-repo) echo "Attach existing project directory to new remote repository" ;;
        init-new-repo) echo "Create new repository with full configuration" ;;
        
        # Tools management
        set-permissions) echo "Make scripts and binaries executable" ;;
        sync-submodules) echo "Update all git submodules to latest versions" ;;
        build) echo "Compile tools from sources directory" ;;
        init-tools) echo "Complete setup: build, configure, permissions" ;;
        configure-shell) echo "Setup shell to source tools configuration" ;;
        init-new-tool) echo "Initialize new tool repository as submodule" ;;
        
        # Git tools
        git-status-overview) echo "System-wide git repository status overview with priority sorting" ;;
        github-stats) echo "Display GitHub repository statistics and metrics" ;;
        
        # Default for unknown tools
        *) echo "$(basename "$file")" ;;
    esac
}

# Build menu data
build_menu_data() {
    local commands=()
    local names=()
    local descriptions=()
    local counter=1
    
    # Add executables from bin/
    if [[ -d "$BIN_DIR" ]]; then
        for file in "$BIN_DIR"/*; do
            if [[ -f "$file" && -x "$file" ]]; then
                local basename=$(basename "$file")
                local description=$(get_description "$file")
                commands+=("$file")
                names+=("$basename")
                descriptions+=("$description")
                ((counter++))
            fi
        done
    fi
    
    # Add scripts
    if [[ -d "$SCRIPTS_DIR" ]]; then
        for file in "$SCRIPTS_DIR"/*; do
            if [[ -f "$file" && -x "$file" ]]; then
                local basename=$(basename "$file")
                # Skip this script itself
                if [[ "$basename" != "tools" ]]; then
                    local description=$(get_description "$file")
                    commands+=("$file")
                    names+=("$basename")
                    descriptions+=("$description")
                    ((counter++))
                fi
            fi
        done
    fi
    
    # Store arrays in global variables
    MENU_COMMANDS=("${commands[@]}")
    MENU_NAMES=("${names[@]}")
    MENU_DESCRIPTIONS=("${descriptions[@]}")
    TOTAL_ITEMS=${#commands[@]}
}

# Display the menu
display_menu() {
    local counter=1
    local in_bin_section=true
    local bin_header_shown=false
    local scripts_header_shown=false
    
    for i in "${!MENU_COMMANDS[@]}"; do
        local file="${MENU_COMMANDS[i]}"
        local name="${MENU_NAMES[i]}"
        local description="${MENU_DESCRIPTIONS[i]}"
        
        # Check if we're in bin/ or scripts/
        if [[ "$file" == "$BIN_DIR"/* ]]; then
            if [[ "$bin_header_shown" == false ]]; then
                echo -e "${CYAN}â”€â”€ ðŸ“¦ EXECUTABLES (bin/) â”€â”€${NC}"
                echo
                bin_header_shown=true
            fi
        else
            if [[ "$in_bin_section" == true ]]; then
                in_bin_section=false
                if [[ "$bin_header_shown" == true ]]; then
                    echo
                fi
            fi
            if [[ "$scripts_header_shown" == false ]]; then
                echo -e "${CYAN}â”€â”€ ðŸ“œ SCRIPTS (scripts/) â”€â”€${NC}"
                echo
                scripts_header_shown=true
            fi
        fi
        
        printf "${YELLOW}%2d)${NC} ${GREEN}%s${NC}\n" "$counter" "$name"
        printf "    ${WHITE}%s${NC}\n\n" "$description"
        ((counter++))
    done
}

# Get user selection (single keypress)
get_selection() {
    local choice
    echo -ne "${YELLOW}Press (1-$TOTAL_ITEMS) or 'q' to quit: ${NC}"
    read -n 1 -s choice
    echo  # Add newline after keypress
    
    if [[ "$choice" == "q" || "$choice" == "Q" ]]; then
        echo -e "${WHITE}Goodbye!${NC}"
        exit 0
    fi
    
    # Validate numeric input
    if ! [[ "$choice" =~ ^[0-9]$ ]] || [[ "$choice" -lt 1 ]] || [[ "$choice" -gt $TOTAL_ITEMS ]]; then
        echo -e "${RED}Invalid choice. Press a number between 1 and $TOTAL_ITEMS${NC}"
        sleep 1
        return 1
    fi
    
    SELECTED_CHOICE="$choice"
    return 0
}

# Main function
main() {
    # Build the menu data first
    build_menu_data
    
    if [[ $TOTAL_ITEMS -eq 0 ]]; then
        echo -e "${RED}No tools found in bin/ or scripts/ directories${NC}"
        exit 1
    fi
    
    while true; do
        # Clear screen and show header
        clear
        echo -e "${CYAN}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${NC}"
        echo -e "${CYAN}â”‚${NC}            ${MAGENTA}Tools Launcher${NC}             ${CYAN}â”‚${NC}"
        echo -e "${CYAN}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${NC}"
        echo
        
        # Display the menu
        display_menu
        
        # Get user selection
        if ! get_selection; then
            echo
            continue
        fi
        
        # Find the corresponding command
        local command="${MENU_COMMANDS[$((SELECTED_CHOICE - 1))]}"
        local tool_name=$(basename "$command")
        
        echo
        echo -e "${MAGENTA}Running: ${GREEN}$tool_name${NC}"
        echo -e "${WHITE}Command: $command${NC}"
        echo
        
        # Run the command directly
        echo -e "${GREEN}Executing...${NC}"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        $command
        
        echo
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo -e "${WHITE}Command completed.${NC}"
        echo
        
        # Ask if user wants to continue
        echo -ne "${YELLOW}Run another tool? Press any key to continue or 'q' to quit: ${NC}"
        read -n 1 -s continue_choice
        echo
        
        if [[ "$continue_choice" == "q" || "$continue_choice" == "Q" ]]; then
            echo -e "${WHITE}Goodbye!${NC}"
            exit 0
        fi
    done
}

main